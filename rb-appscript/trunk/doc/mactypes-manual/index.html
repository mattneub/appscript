<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>

<title>mactypes</title>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<style type="text/css" media="all"><!--@import url(../appscript-manual/full.css);--></style>

</head>
<body>

<h1>mactypes</h1>

<!-- top navigation -->
<div class="navbar">
    <a href="index.html">Up</a>
    
</div>

<!-- content -->
<div id="content">
<h2>What is mactypes?</h2>

<p>The mactypes module provides user-friendly wrappers for OS X Alias and File objects, commonly used by scriptable applications to identify filesystem objects and locations, and for unit type values used by some applications to represent lengths, etc.</p>

<p class="hilitebox">Note that most scriptable applications do not use or understand POSIX paths, and while the Apple Event Manager does provide some built-in coercions for converting between path strings and alias/file objects, these work with HFS paths only. Therefore, when specifying files and folders to scriptable applications, use <code>MacTypes::Alias</code> and <code>MacTypes::File</code> objects - not path strings - unless otherwise indicated.</p>


<h2><code>MacTypes::Alias</code></h2>

<p>The <code>Alias</code> class represents a persistent reference to a filesystem object. Aliases keep track of filesystem objects even if they're renamed or moved to another location on the same disk.</p>


<h3>Methods</h3>

<pre><code>Alias -- a persistent reference to a filesystem object
    Constructors:

        Alias.path(path) -- make Alias object from POSIX path
    
        Alias.desc(desc) -- make Alias object from an AE::AEDesc
                            of TypeAlias

    Methods:
    
        path -- returns POSIX path string to the object's current location

        desc -- returns AE::AEDesc of TypeAlias

        to_s -- synonym for #path
    
        inspect -- returns string representation of Alias object
    
        to_alias -- returns self
    
        to_fileurl -- returns a MacTypes::FileURL object</code></pre>


<h3>Examples</h3>

<pre><code>require "appscript"
require "mactypes"

f = MacTypes::Alias.path('/Users/foo/some file')

puts f.to_s
# /Users/foo/some file

puts f.inspect
# MacTypes::Alias.path("/Users/foo/some file")

AS.app('TextEdit').open(f)
# opens document in TextEdit</code></pre>



<h2><code>MacTypes::FileURL</code></h2>

<p>The <code>FileURL</code> class represents a fixed filesystem location. This may be deterministic (i.e. existing locations only) or non-deterministic depending on how the object is created.</p>

<h3>Methods</h3>

<pre><code>FileURL -- identifies a fixed filesystem location
    Constructors:

        FileURL.path(path) -- make FileURL object from POSIX path
    
        FileURL.desc(desc) -- make FileURL object from an AE::AEDesc
                              of TypeFSS, TypeFSRef or TypeFileURL

    Methods:
    
        path -- returns POSIX path string

        desc -- returns AE::AEDesc of TypeFSRef, TypeFSS or TypeFileURL

        to_s -- synonym for #path
    
        inspect -- returns string representation of FileURL object
    
        to_alias -- returns a MacTypes::Alias object
    
        to_fileurl -- returns a new MacTypes::FileURL object</code></pre>

<h3>Examples</h3>

<pre><code>require "appscript"
require "mactypes"

f = MacTypes::FileURL.path('/Users/foo/new file')

puts f.to_s
# /Users/foo/new file

puts f.inspect
# MacTypes::FileURL.path("/Users/foo/new file")

AS.app('TextEdit').documents[1].save(:in => f)
# saves front TextEdit document at the given location</code></pre>


<h3>Notes</h3>

<p>Unlike the <code>Alias</code> class which wraps <code>TypeAlias</code> values only, the <code>FileURL</code> class provides a uniform wrapper for several file-related types that may be returned by applications: <code>TypeFSS</code>, <code>TypeFSRef</code> and <code>TypeFileURL</code>. When passing <code>FileURL</code> values to applications, you should not normally need to worry about which value type a <code>FileURL</code> object contains as well-designed applications will ask the Apple Event Manager to coerce the given value to the desired type as necessary.</p>

<p>When dealing with less well-behaved applications, however, you may need to pass an AEDesc of a specific type. In this case you should use the <code>desc</code> method to obtain an <code>AE::AEDesc</code> object, then call its <code>coerce</code> method to obtain an AEDesc of the desired type. For example, if an older Carbon application refuses to accept a FileURL identifying a non-existing file location, you may need to provide a FSSpec insteaf:</p>

<pre><code>require "mactypes"
require "kae"

fileURL = MacTypes::FileURL.path('/Users/foo/new file')

fsspec = fileURL.desc.coerce(KAE::TypeFSS)

AS.app('older app').documents[1].save(:in => fsspec)</code></pre>

<p>When used in an application command, a <code>FileURL</code> object returned by appscript will always pack into the same <code>TypeFSRef</code>, <code>TypeFileURL</code> or <code>TypeFSS</code> AEDesc it was created from. A <code>FileURL</code> object returned by <code>FileURL.path</code>, <code>Alias#to_fileurl</code> or <code>FileURL#to_fileurl</code> will always pack into an AEDesc of <code>TypeFileURL</code>.</p>

<p>Note that AEDescs of <code>TypeFSRef</code> can represent existing filesystem locations only. AEDescs of <code>TypeFileURL</code> can represent both existing and non-existing locations. AEDescs of <code>TypeFSS</code> (FSSpecs) are deprecated on Mac OS X due to lack of proper Unicode and long filename support, and are retained for backwards compatibility with older applications only.</p>




<h2><code>MacTypes::FileNotFoundError</code></h2>

<p><code>FileNotFoundError</code> is a subclass of <code>RuntimeError</code>. It is raised by <code>Alias</code> and <code>FileURL</code> objects when an operation that only works for existing filesystem objects/locations fails. For example:</p>

<pre><code>require "mactypes"

MacTypes::Alias.path('/some/non/existent/location')
# raises FileNotFoundError</code></pre>


<h2><code>MacTypes::Units</code></h2>

<!-- TO DO -->


</div>

<!-- bottom navigation -->
<div class="navbar">
    <a href="index.html">Up</a>
    
</div>

<!--footer-->
<p class="footer">&copy; 2006 HAS</p>
</body>
</html>