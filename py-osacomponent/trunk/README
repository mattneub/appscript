PyOSA

======================================================================
IMPORTANT

- This is an early developer release, so is incomplete and may be buggy. Use at your own risk, etc.

- Note that the version of Script Editor included with Mac OS X 10.4.x contains bugs that can prevent scripts loading or compiling correctly. Script Editor users should read the NOTES > Script Editor Workarounds section below before using PyOSA.


======================================================================
SUMMARY

A Python OSA language component.


======================================================================
INSTALLATION

- Install py-appscript 0.17.2 or later <http://appscript.sourceforge.net> for Mac OS X's Apple-installed Python framework and any user-installed Python frameworks.

- Copy the PyOSA.component bundle to /Library/Components or ~/Library/Components. OSA-aware applications will detect PyOSA the next time they are launched.


======================================================================
DESCRIPTION

PyOSA is Python interpreter repackaged as an OSA language component, allowing OSA scripts to be written in Python. It is intended to be a fully-fledged OSA component and as such has some usage differences to the standard [Mac]Python:

1. PyOSA scripts are managed similarly to Python modules, being executed at load/compile time to initialise all top-level variables, functions, etc. prior to use. This means that global variables will retain their current state between runs until the script is recompiled/reloaded.
It also means that one or more top-level functions must be provided as entry points, e.g. a PyOSA script intended for batch-processing use must provide a run handler to be called when the script is run. Example:

def run():
	return "Hello world!"

Note that this means PyOSA is unsuitable for running conventional Python batch-processing scripts, unless they're modified to suit.

2. PyOSA uses the host process's stdout and stderr. Use Console.app to view the results of 'print' statements. To send messages to the event log (e.g. in Script Editor), use PyOSA's log(msg=None) method.

3. PyOSA doesn't support importing modules relative to a PyOSA script as the OSA is not properly filesystem-aware. Python modules must be located on the standard sys.path, or in the following folders:

	/Library/PyOSA/X.Y/site-packages
	~/Library/PyOSA/X.Y/site-packages

where X and Y are the major and minor version numbers of the Python framework being used, e.g.:

	 /Library/PyOSA/2.5/site-packages

There is currently no support for using compiled OSA scripts as modules.


4. Compiled PyOSA scripts (.scpt/.app) can contain persistent script data in addition to the script source code (see below).


5. PyOSA adds several top-level variables to each script before initialising it: 

- aem -- the aem module
- appscript -- the appscript module
- app, con, its, k, ApplicationNotFoundError, CommandError -- appscript's public attributes
- state -- provides a persistent data storage area; data stored here will be retained after script is saved to disk, and restored when script is loaded from disk
- log -- the log function
- parent -- used to pass commands to the script's parent (currently this is always the host application)
- installeventhandler -- used to manually install functions as Apple event handlers

6. PyOSA scripts can handle Apple events simply by declaring handler functions at the top level of the script. Functions whose names are defined as commands/events in the host application's dictionary will be automatically installed as event handlers for that script.

Example: save the following script as an applet, then drop one or more files/folders onto it:

def open(aliaslist):
	print 'OPENING:', aliaslist

Handler functions can also be installed by the script if necessary, e.g. if the host application has no dictionary. This is done using the installeventhandler function. (TO DO: document this.)


======================================================================
INTERFACE

======= Sending events to the host process =======

Events can be passed to the host process in either of two ways:

1. using app() - i.e. the current application - as the target, e.g.:

	app().name.get()

This is equivalent to using 'get name' in AppleScript.


2. using parent - i.e. the script's delegate - as the target, e.g.:

	parent.name.get()

This is equivalent to using 'continue get name' in AppleScript.


------- Notes -------

- When implementing 'quit' handlers in script applets, remember to forward the 'quit' event to the script's parent (i.e. the applet shell) otherwise the application will fail to quit, e.g.:

	def quit(): # override the applet's own internal quit handler to add additional behaviour
		# do stuff
		parent.quit() # must be called to allow the application to quit
		# do more stuff

(Don't use app().quit() here otherwise an infinite recursion error will occur.)


======= Persistent state =======

The state variable contains a new-style class instance to which you can add, get and remove any attribute at any time, this provides a convenient facade for PyOSA's persistence mechanism. To set initial state at compilation time, call state with one or more named arguments, e.g.:

	state(
		var1 = 42,
		var2 = []
	)

When a script is saved in compiled form, PyOSA will attempt to serialise the state object's __dict__ and store it in the script file along with the script's source code and other data. When the script is re-loaded, PyOSA restores the state object's attributes to their previously stored state. The client application can also query the PyOSA component to see if osastore's content has changed since the script was loaded. 

Note that this persistence mechanism is reliant on Python's pickle module, so can't handle complex values such as functions, classes and instances. If serialisation fails, a warning is printed to stderr and the state data is omitted.

======================================================================
NOTES

======= About OSA =======

The Open Scripting Architecture defines a standard API and bundle format for creating scripting language plugins. Once a scripting language is packaged as an OSA component, applications can load and run scripts written in that language without having to deal with language-specific APIs. (When using compiled scripts, the application doesn't even need to know what language the script is written in!)

The best known OSA language is Apple's own AppleScript language There are several other OSA languages of varying capabilities currently available:
- UserTalk <http://radio.userland.com>
- OSAShell <http://ranchero.com/software/osashell>
- JavaScriptOSA <http://www.latenightsw.com/freeware/JavaScriptOSA>
- TclOSA, PerlOSA, PythonOSA, PHPOSA, RubyOSA, ShOSA <http://homepage.mac.com/philip_aker/osa/osa.html>

OSA scripts are commonly used in 'attachable' applications such as System Events and Mail to modify and extend their standard behaviour. An attachable application is one that allows OSA scripts to be attached to various objects - Script menus, objects within the application's Apple Event Object Model, etc. - to modify and extend the application's functionality. e.g. System Events allows scripts to be attached as Folder Actions and triggered when a filesystem folder is modified by the user; Mail allows scripts to be used as custom Mail Rule actions. 

OSA scripts are also heavily used in OSA-based application development kits such as AppleScript Studio and FaceSpan. (Note that AppleScript Studio and FaceSpan currently provide direct support for the AppleScript language only.)

OSA scripts are typically written using an OSA script editor such as Apple's own Script Editor or Late Night Software's Script Debugger. Compiled OSA script files typically have a .scpt extension. Be aware that some OSA editors may not recognise source code files with .py extensions; where this is the case you'll need to copy and paste source code between applications.


======= PyOSA Notes =======

- PyOSA dynamically loads the Python framework. The search order is as follows:

	- If the host process already has a Python framework loaded, use that.
	- If the host application bundle contains a private Python framework, load and use that.
	- Search the following locations for a public Python framework and use the first one found:
		~/Library/Frameworks/Python.framework
		/Library/Frameworks/Python.framework
		/Network/Library/Frameworks/Python.framework
		/System/Library/Frameworks/Python.framework

Python 2.3 and later are supported (though some may generate interface version warnings as 100% compatibility support isn't yet complete).

- Appscript 0.17.2 or later must be installed in the Python framework used by PyOSA. If appscript is not found, or is an older version, an error message will be printed to Console and the component will refuse to load. (This is to protect against hard crashes due to API incompatibilities with older CarbonX.AE extensions.)


======= PyOSA Known Issues =======

- PyOSA currently hosts all component and script instances in a single Python interpreter. This means that all scripts share the same modules, file handles, etc. so it's up to script authors to ensure they don't interfere with one another. In addition, host applications that call OSA components from multiple threads will very likely run into problems. Providing better insulation between scripts is planned, assuming this is practical.

- Don't create osax.ScriptingAddition instances at the top level of an applet script as this currently causes the applet to error/crash. (Creating the ScriptingAddition instance within an event handler appears to work okay, however.)

- While some parts of PyOSA are fully functional, other bits are jury-rigged or not yet implemented, so don't be surprised if some features don't work correctly/at all.

- The public APIs are not yet finalised and may be subject to change.

- PyOSA currently contains debugging code that prints various status messages to stderr while PyOSA is working. (When compiling and running PyOSA scripts from GUI applications, these messages will appear in Console.app.) There is currently no way to disable these messages, short of disabling the debug code by hand and rebuilding the component. This will be addressed in a future release.


======= Script Editor Workarounds =======

The Script Editor application that ships with Mac OS X 10.4.x has known bugs in its OSA language support that can prevent scripts not written in the default language (normally AppleScript) from loading or compiling correctly. (Note that MacOS X 10.3's Script Editor and Script Debugger do not have this problem.) 

The workaround is to set the default language in Script Editor's General Preferences to 'PyOSA' and restart it. (To switch back to editing AppleScripts, set the default language to 'AppleScript' and restart Script Editor again.)

Alternatively, use osacompile to convert .py files into .scpt or .app files, e.g.:

	osacompile  -l PyOSA  -o myscript.scpt  myscript.py

	osacompile  -l PyOSA  -o myscript.app  myscript.py

See the osacompile manpage for more details.


======= Other =======

- Offers of advice, assistance, additional documentation, etc. from anyone familiar with the finer points of OSA component design would be greatly appreciated!


======================================================================
SUBVERSION

PyOSA:

	svn checkout http://svn.macosforge.org/repository/appscript/py-osacomponent/trunk/


======================================================================
HISTORY

- 2007-03-28 -- 0.1.1; fixes compatibility problem with Script Debugger 4; some improvements in event log support

- 2007-03-26 -- 0.1.0; first release


======================================================================
AUTHOR

- has <hhas -at- users - sourceforge - net> <http://appscript.sourceforge.net>


======================================================================
THANKS

Many thanks to: Philip Aker, Bill Fancher, Bob Ippolito, Chris Nebel, Donovan Preston, Brent Simmons


======================================================================
COPYRIGHT

(C) 2007 HAS

PyOSA is released under the MIT License. See LICENSE for details.
